// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#include "PipelineLayout.h"
#include "DescriptorSet.h"
#include "DescriptorSetSignatureFile.h"
#include "ObjectFactory.h"
#include "Pools.h"
#include "DescriptorSetSignatureFile.h"
#include "IncludeVulkan.h"
#include "../../../OSServices/Log.h"
#include "../../../Utility/Threading/Mutex.h"
#include "../../../Utility/Streams/StreamFormatter.h"
#include "../../../Utility/MemoryUtils.h"
#include "../../../xleres/FileList.h"
#include <iostream>

static const char* s_rootSignatureGraphicsDefault = R"--(
~~ ValidDescriptorTypes:
~~		Sampler = VK_DESCRIPTOR_TYPE_SAMPLER
~~		VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
~~		Texture = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
~~		UnorderedAccessTexture = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
~~		VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
~~		VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
~~		ConstantBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
~~		UnorderedAccessBuffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
~~		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
~~		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
~~		VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT

DescriptorSet=~
	name = Sequencer
	Descriptors=~
		type = ConstantBuffer
		slots = 0..6
	Descriptors=~
		type = Texture
		slots = 6..13

DescriptorSet=~
	name = Material
	Descriptors=~
		type = ConstantBuffer
		slots = 0..3
	Descriptors=~
		type = Texture
		slots = 3..11
	Descriptors=~
		type = UnorderedAccessBuffer
		slots = 11

DescriptorSet=~
	name = Draw
	Descriptors=~
		type = Texture
		slots = 0..10

DescriptorSet=~
	name = Numeric
	Descriptors=~
		type = Texture
		slots = 0..16
	Descriptors=~
		type = Sampler
		slots = 16..23
	Descriptors=~
		type = ConstantBuffer
		slots = 23..27
	Descriptors=~
		type = Sampler
		slots = 27

PushConstants=~
	name = LocalTransform
	slots = 0..64(v)

~~~~ Here we map the HLSL register bindings onto descriptors sets for Vulkan
~~~~ Since our shaders were originally written for DX11, resources either don`t
~~~~ have bindings set, or they are just using bindings from in one large contiguous
~~~~ range. For Vulkan we want to separate the resources into descriptor sets, so
~~~~ here we assign ranges in our one contiguous binding block to named descriptor
~~~~ sets.

LegacyBinding=~
	name = MainLegacyBinding
	t0..16=~
		set = Numeric
		mapping = 0..16
	t16..23=~
		set = Sequencer
		mapping = 6..13
	t23..31=~
		set = Material
		mapping = 3..11
	t27(buffer)=~
		set = Material
		mapping = 11

	s0..7=~
		set = Numeric
		mapping = 16..23
	s16=~		~~ (this the DummySampler generated by the HLSLCrossCompiler)
		set = Numeric
		mapping = 27

	b0..4=~
		set = Numeric
		mapping = 23..27
	b4..7=~
		set = Material
		mapping = 0..3
	b7..13=~
		set = Sequencer
		mapping = 0..6

RootSignature=~
	name = GraphicsMain
	Set=~
		name = Sequencer
		type = Adaptive
		uniformStream = 0
	Set=~
		name = Material
		type = Adaptive
		uniformStream = 1
	Set=~
		name = Draw
		type = Adaptive
		uniformStream = 2
	Set=~
		name = Numeric
		type = Numeric
	legacyBindings = MainLegacyBinding
	PushConstants=~
		name = LocalTransform

MainRootSignature = GraphicsMain
)--";

namespace RenderCore { namespace Metal_Vulkan { namespace Internal
{
#if 0
	class BoundSignatureFile::Pimpl
	{
	public:
		std::vector<std::pair<uint64_t, DescriptorSet>> _descriptorSetLayouts;
		VkShaderStageFlags								_stageFlags;
		ObjectFactory*		_factory;
		GlobalPools*		_globalPools;
	};

	auto BoundSignatureFile::GetDescriptorSet(uint64_t signatureFile, uint64_t hashName) const -> const DescriptorSet*
	{
		auto h = HashCombine(signatureFile, hashName);
		auto i = LowerBound(_pimpl->_descriptorSetLayouts, h);
		if (i != _pimpl->_descriptorSetLayouts.end() && i->first == h)
			return &i->second;
		return nullptr;
	}

	void BoundSignatureFile::RegisterSignatureFile(uint64_t hashName, const DescriptorSetSignatureFile& signatureFile)
	{
		// Each descriptor set layout is initialized from the root signature
		// This allows us to create a single global setting that can be used broadly across
		// many "pipelines"

		#if defined(_DEBUG)
			ValidateRootSignature(_pimpl->_factory->GetPhysicalDevice(), signatureFile);
		#endif

		_pimpl->_descriptorSetLayouts.reserve(_pimpl->_descriptorSetLayouts.size() + signatureFile._descriptorSets.size());

		for (const auto& s:signatureFile._descriptorSets) {
			DescriptorSet ds;
			ds._layout = CreateDescriptorSetLayout(*_pimpl->_factory, *s, _pimpl->_stageFlags);
			
			{
				DescriptorSetBuilder builder(*_pimpl->_globalPools);
				builder.BindDummyDescriptors(*s, (1ull<<uint64_t(s->_bindings.size()))-1ull);
				ds._blankBindings = _pimpl->_globalPools->_longTermDescriptorPool.Allocate(ds._layout.get());
				VULKAN_VERBOSE_DEBUG_ONLY(ds._blankBindingsDescription._descriptorSetInfo = s_dummyDescriptorSetName);
				builder.FlushChanges(
					_pimpl->_factory->GetDevice().get(),
					ds._blankBindings.get(),
					0, 0 VULKAN_VERBOSE_DEBUG_ONLY(, ds._blankBindingsDescription));
			}

			VULKAN_VERBOSE_DEBUG_ONLY(ds._name = s->_name);
			_pimpl->_descriptorSetLayouts.emplace_back(std::make_pair(HashCombine(hashName, s->_hashName), std::move(ds)));
		}
		std::sort(
			_pimpl->_descriptorSetLayouts.begin(),
			_pimpl->_descriptorSetLayouts.end(),
			CompareFirst<uint64_t, DescriptorSet>());
	}

	BoundSignatureFile::BoundSignatureFile(ObjectFactory& objectFactory, GlobalPools& globalPools, VkShaderStageFlags stageFlags)
	{
		_pimpl = std::make_unique<Pimpl>();
		_pimpl->_stageFlags = stageFlags;
		_pimpl->_factory = &objectFactory;
		_pimpl->_globalPools = &globalPools;
	}

	BoundSignatureFile::~BoundSignatureFile()
	{}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////

	struct CompiledDescriptorSetLayout
	{
		VulkanSharedPtr<VkDescriptorSetLayout>	_layout;
		VulkanSharedPtr<VkDescriptorSet>		_blankBindings;
		
		#if defined(VULKAN_VERBOSE_DEBUG)
			DescriptorSetDebugInfo _blankBindingsDescription;
			std::string _name;
		#endif
	};

	class CompiledDescriptorSetLayoutCache
	{
	public:
		const CompiledDescriptorSetLayout*	CompileDescriptorSetLayout(
			const DescriptorSetSignature& signature,
			VkShaderStageFlags stageFlags);

		CompiledDescriptorSetLayoutCache(ObjectFactory& objectFactory, GlobalPools& globalPools);
		~CompiledDescriptorSetLayoutCache();
	private:
		ObjectFactory*	_objectFactory;
		GlobalPools*	_globalPools;

		std::vector<std::pair<uint64_t, std::unique_ptr<CompiledDescriptorSetLayout>>> _cache;
	};

	static const std::string s_dummyDescriptorString{"<DummyDescriptor>"};

	const CompiledDescriptorSetLayout*	CompiledDescriptorSetLayoutCache::CompileDescriptorSetLayout(
		const DescriptorSetSignature& signature,
		VkShaderStageFlags stageFlags)
	{
		auto hash = HashCombine(signature.GetHash(), stageFlags);
		auto i = LowerBound(_cache, hash);
		if (i != _cache.end() && i->first == hash)
			return i->second.get();

		auto ds = std::make_unique<CompiledDescriptorSetLayout>();
		ds->_layout = CreateDescriptorSetLayout(*_objectFactory, signature, stageFlags);
		
		{
			DescriptorSetBuilder builder(*_globalPools);
			builder.BindDummyDescriptors(signature, (1ull<<uint64_t(signature._bindings.size()))-1ull);
			ds->_blankBindings = _globalPools->_longTermDescriptorPool.Allocate(ds->_layout.get());
			VULKAN_VERBOSE_DEBUG_ONLY(ds->_blankBindingsDescription._descriptorSetInfo = s_dummyDescriptorString);
			builder.FlushChanges(
				_objectFactory->GetDevice().get(),
				ds->_blankBindings.get(),
				0, 0 VULKAN_VERBOSE_DEBUG_ONLY(, ds->_blankBindingsDescription));
		}

		VULKAN_VERBOSE_DEBUG_ONLY(ds->_name = signature._name);

		i = _cache.insert(i, std::make_pair(hash, std::move(ds)));
		return i->second.get();
	}

	CompiledDescriptorSetLayoutCache::CompiledDescriptorSetLayoutCache(ObjectFactory& objectFactory, GlobalPools& globalPools)
	: _objectFactory(&objectFactory)
	, _globalPools(&globalPools)
	{}

	CompiledDescriptorSetLayoutCache::~CompiledDescriptorSetLayoutCache() {}

	std::shared_ptr<CompiledDescriptorSetLayoutCache> CreateCompiledDescriptorSetLayoutCache(ObjectFactory& objectFactory, GlobalPools& globalPools)
	{
		return std::make_shared<CompiledDescriptorSetLayoutCache>(objectFactory, globalPools);
	}

	VulkanPipelineLayout::VulkanPipelineLayout(
		ObjectFactory& factory,
		CompiledDescriptorSetLayoutCache& cache,
		IteratorRange<const PartialPipelineDescriptorsLayout*> partialLayouts,
		VkShaderStageFlags stageFlags)
	{
		_descriptorSetCount = 0;
		std::vector<VkPushConstantRange> rawPushConstantRanges;
		VkDescriptorSetLayout rawDescriptorSetLayouts[s_maxDescriptorSetCount];

		for (const auto&partial:partialLayouts) {
			for (auto& desc:partial._descriptorSets) {
				assert(desc._pipelineLayoutBindingIndex < s_maxDescriptorSetCount);
				assert(!_descriptorSetLayouts[desc._pipelineLayoutBindingIndex]);

				auto* compiled = cache.CompileDescriptorSetLayout(*desc._signature, stageFlags);
				if (compiled) {
					// todo -- check for multiples bound to the same index
					assert(desc._pipelineLayoutBindingIndex < s_maxDescriptorSetCount);
					_descriptorSetLayouts[desc._pipelineLayoutBindingIndex] = compiled->_layout;
					_blankDescriptorSets[desc._pipelineLayoutBindingIndex] = compiled->_blankBindings;
					_descriptorSetCount = std::max(_descriptorSetCount, desc._pipelineLayoutBindingIndex+1);
					rawDescriptorSetLayouts[desc._pipelineLayoutBindingIndex] = _descriptorSetLayouts[desc._pipelineLayoutBindingIndex].get();
					_descriptorSetSignature[desc._pipelineLayoutBindingIndex] = desc._signature;

					#if defined(VULKAN_VERBOSE_DEBUG)
						_blankDescriptorSetsDebugInfo[desc._pipelineLayoutBindingIndex] = compiled->_blankBindingsDescription;
					#endif
				}
			}

			rawPushConstantRanges.reserve(rawPushConstantRanges.size() + partial._pushConstants.size());
			for (const auto& s:partial._pushConstants)
				rawPushConstantRanges.push_back(VkPushConstantRange{s._stages, s._rangeStart, s._rangeSize});
		}

		// todo -- we should check if there's any overlaps between push constant ranges
		// todo -- we also need a way to return the blank bindings back to the caller
		_pipelineLayout = factory.CreatePipelineLayout(
			MakeIteratorRange(rawDescriptorSetLayouts, &rawDescriptorSetLayouts[_descriptorSetCount]),
			MakeIteratorRange(rawPushConstantRanges));

		#if defined(VULKAN_VERBOSE_DEBUG)
			if (!partialLayouts.empty()) {
				_legacyRegisterBinding = partialLayouts[0]._legacyRegisterBinding;
			} else {
				_legacyRegisterBinding = std::make_shared<LegacyRegisterBinding>();
			}
		#endif
	}

	#if defined(VULKAN_VERBOSE_DEBUG)
		void VulkanPipelineLayout::WriteDebugInfo(
			std::ostream&& output,
			IteratorRange<const CompiledShaderByteCode**> shaders,
			IteratorRange<const DescriptorSetDebugInfo*> descriptorSets)
		{
			Log(Verbose) << "-------------Descriptors------------" << std::endl;
			for (unsigned descSetIdx=0; descSetIdx<s_maxDescriptorSetCount; ++descSetIdx) {
				WriteDescriptorSet(
					std::move(output),
					(descSetIdx < descriptorSets.size()) ? descriptorSets[descSetIdx] : _blankDescriptorSetsDebugInfo[descSetIdx],
					*_descriptorSetSignature[descSetIdx],
					*_legacyRegisterBinding,
					shaders,
					descSetIdx,
					descSetIdx < descriptorSets.size());
			}
		}
	#endif

///////////////////////////////////////////////////////////////////////////////////////////////////

	#if defined(_DEBUG)
		class DescSetLimits
		{
		public:
			unsigned _sampledImageCount;
			unsigned _samplerCount;
			unsigned _uniformBufferCount;
			unsigned _storageBufferCount;
			unsigned _storageImageCount;
			unsigned _inputAttachmentCount;

			void Add(const DescSetLimits& other)
			{
				_sampledImageCount += other._sampledImageCount;
				_samplerCount += other._samplerCount;
				_uniformBufferCount += other._uniformBufferCount;
				_storageBufferCount += other._storageBufferCount;
				_storageImageCount += other._storageImageCount;
				_inputAttachmentCount += other._inputAttachmentCount;
			}
		};

		static DescSetLimits BuildLimits(const DescriptorSetSignature& setSig)
		{
			DescSetLimits result = {};
			for (auto& b:setSig._bindings) {
				switch (b) {
				case DescriptorType::Sampler:
					++result._samplerCount;
					break;

				case DescriptorType::Texture:
					++result._sampledImageCount;
					break;

				case DescriptorType::ConstantBuffer:
					++result._uniformBufferCount;
					break;

				case DescriptorType::UnorderedAccessBuffer:
					++result._storageBufferCount;
					break;

				case DescriptorType::UnorderedAccessTexture:
					++result._storageImageCount;
					break;

				default:
					break;
				}
			}
			return result;
		}

		static void ValidateRootSignature(
			VkPhysicalDevice physDev,
			const DescriptorSetSignatureFile& signatureFile)
		{
			// Validate the root signature against the physical device, and throw an exception
			// if there are problems.
			// Things to check:
			//      VkPhysicalDeviceLimits.maxBoundDescriptorSets
			//      VkPhysicalDeviceLimits.maxPerStageDescriptor*
			//      VkPhysicalDeviceLimits.maxDescriptorSet*

			VkPhysicalDeviceProperties props;
			vkGetPhysicalDeviceProperties(physDev, &props);
			const auto& limits = props.limits;

			for (const auto& rootSig:signatureFile._rootSignatures) {
				if (rootSig._descriptorSets.size() > limits.maxBoundDescriptorSets)
					Throw(::Exceptions::BasicLabel("Root signature exceeds the maximum number of bound descriptor sets supported by device"));
			}

			// Here, we are assuming all descriptors apply equally to all stages.
			DescSetLimits totalLimits = {};
			for (const auto& s:signatureFile._descriptorSets) {
				auto ds = BuildLimits(*s);
				// not really clear how these ones work...?
				if (    ds._sampledImageCount > limits.maxDescriptorSetSampledImages
					||  ds._samplerCount > limits.maxPerStageDescriptorSamplers
					||  ds._uniformBufferCount > limits.maxPerStageDescriptorUniformBuffers
					||  ds._storageBufferCount > limits.maxPerStageDescriptorStorageBuffers
					||  ds._storageImageCount > limits.maxPerStageDescriptorStorageImages
					||  ds._inputAttachmentCount > limits.maxPerStageDescriptorInputAttachments)
					Throw(::Exceptions::BasicLabel("Root signature exceeds the maximum number of bound resources in a single descriptor set that is supported by the device"));
				totalLimits.Add(ds);
			}

			if (    totalLimits._sampledImageCount > limits.maxDescriptorSetSampledImages
				||  totalLimits._samplerCount > limits.maxPerStageDescriptorSamplers
				||  totalLimits._uniformBufferCount > limits.maxPerStageDescriptorUniformBuffers
				||  totalLimits._storageBufferCount > limits.maxPerStageDescriptorStorageBuffers
				||  totalLimits._storageImageCount > limits.maxPerStageDescriptorStorageImages
				||  totalLimits._inputAttachmentCount > limits.maxPerStageDescriptorInputAttachments)
				Throw(::Exceptions::BasicLabel("Root signature exceeds the maximum number of bound resources per stage that is supported by the device"));
		}
	#endif

	VulkanGlobalsTemp& VulkanGlobalsTemp::GetInstance()
	{
		static VulkanGlobalsTemp s_instance;
		return s_instance;
	}

	const std::shared_ptr<VulkanPipelineLayout>& VulkanGlobalsTemp::GetPipelineLayout(const ShaderProgram&)
	{
		return _graphicsPipelineLayout;
	}
	const std::shared_ptr<VulkanPipelineLayout>& VulkanGlobalsTemp::GetPipelineLayout(const ComputeShader&)
	{
		return _computePipelineLayout;
	}

	VulkanGlobalsTemp::VulkanGlobalsTemp() 
	{
		for (unsigned c=0; c<4; ++c) {
			_graphicsUniformStreamToDescriptorSetBinding[c] = ~0u;
			_computeUniformStreamToDescriptorSetBinding[c] = ~0u;
		}

		// _graphicsRootSignatureFile = std::make_shared<Metal_Vulkan::DescriptorSetSignatureFile>(ROOT_SIGNATURE_CFG);
		// _computeRootSignatureFile = std::make_shared<Metal_Vulkan::DescriptorSetSignatureFile>(ROOT_SIGNATURE_COMPUTE_CFG);

		// hack -- temporary configuration
		{
			InputStreamFormatter<> formatter(MakeStringSection(s_rootSignatureGraphicsDefault));
			_graphicsRootSignatureFile = std::make_shared<Metal_Vulkan::DescriptorSetSignatureFile>(formatter, ::Assets::DirectorySearchRules{}, nullptr);
		}
		_computeRootSignatureFile = _graphicsRootSignatureFile;
	}

	VulkanGlobalsTemp::~VulkanGlobalsTemp() {}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	std::shared_ptr<PartialPipelineDescriptorsLayout> CreatePartialPipelineDescriptorsLayout(
		const DescriptorSetSignatureFile& signatureFile, PipelineType pipelineType)
	{
		auto result = std::make_shared<PartialPipelineDescriptorsLayout>();

		auto& globals = VulkanGlobalsTemp::GetInstance();
		const auto& root = *signatureFile.GetRootSignature(Hash64(signatureFile._mainRootSignature));
		result->_descriptorSets.reserve(root._descriptorSets.size());
		for (unsigned c=0; c<root._descriptorSets.size(); ++c) {
			const auto&d = root._descriptorSets[c];
			result->_descriptorSets.emplace_back(
				PartialPipelineDescriptorsLayout::DescriptorSet {
					signatureFile.GetDescriptorSet(d._hashName),
					c,
					d._name
				});
		}

		auto shaderStageMask = 0;
		if (pipelineType == PipelineType::Graphics) {
			shaderStageMask = VK_SHADER_STAGE_ALL_GRAPHICS;
		} else {
			shaderStageMask = VK_SHADER_STAGE_COMPUTE_BIT;
		}

		for (unsigned c=0; c<root._pushConstants.size(); ++c) {
			auto* sig = signatureFile.GetPushConstantsRangeSignature(Hash64(root._pushConstants[c]));
			if (sig && (sig->_stages & shaderStageMask)) {
				auto newSig = *sig;
				newSig._stages &= shaderStageMask;
				result->_pushConstants.push_back(std::move(newSig));
			}
		}

		result->_legacyRegisterBinding = signatureFile.GetLegacyRegisterBinding(Hash64(root._legacyBindings));
		return result;
	}
	
}}}

