// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#include "PipelineLayout.h"
#include "DescriptorSet.h"
#include "DescriptorSetSignatureFile.h"
#include "ObjectFactory.h"
#include "Pools.h"
#include "DescriptorSetSignatureFile.h"
#include "IncludeVulkan.h"
#include "../../../OSServices/Log.h"
#include "../../../Utility/Threading/Mutex.h"
#include "../../../Utility/Streams/StreamFormatter.h"
#include "../../../Utility/MemoryUtils.h"
#include "../../../Utility/BitUtils.h"
#include "../../../xleres/FileList.h"
#include <iostream>

static const char* s_rootSignatureGraphicsDefault = R"--(
~~ ValidDescriptorTypes:
~~		Sampler = VK_DESCRIPTOR_TYPE_SAMPLER
~~		VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER
~~		Texture = VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE
~~		UnorderedAccessTexture = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE
~~		VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER
~~		VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER
~~		ConstantBuffer = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER
~~		UnorderedAccessBuffer = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER
~~		VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC
~~		VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC
~~		VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT

DescriptorSet=~
	name = Sequencer
	Descriptors=~
		type = ConstantBuffer
		slots = 0..6
	Descriptors=~
		type = Texture
		slots = 6..13

DescriptorSet=~
	name = Material
	Descriptors=~
		type = ConstantBuffer
		slots = 0..3
	Descriptors=~
		type = Texture
		slots = 3..11
	Descriptors=~
		type = UnorderedAccessBuffer
		slots = 11

DescriptorSet=~
	name = Draw
	Descriptors=~
		type = Texture
		slots = 0..10

DescriptorSet=~
	name = Numeric
	Descriptors=~
		type = Texture
		slots = 0..16
	Descriptors=~
		type = Sampler
		slots = 16..23
	Descriptors=~
		type = ConstantBuffer
		slots = 23..27
	Descriptors=~
		type = Sampler
		slots = 27

PushConstants=~
	name = LocalTransform
	slots = 0..64(v)

~~~~ Here we map the HLSL register bindings onto descriptors sets for Vulkan
~~~~ Since our shaders were originally written for DX11, resources either don`t
~~~~ have bindings set, or they are just using bindings from in one large contiguous
~~~~ range. For Vulkan we want to separate the resources into descriptor sets, so
~~~~ here we assign ranges in our one contiguous binding block to named descriptor
~~~~ sets.

LegacyBinding=~
	t0..16=~
		set = Numeric
		setIndex = 3
		mapping = 0..16
	t16..23=~
		set = 0
		setIndex = 0
		mapping = 6..13
	t23..31=~
		set = Material
		setIndex = 1
		mapping = 3..11
	t27(buffer)=~
		set = Material
		setIndex = 1
		mapping = 11

	s0..7=~
		set = Numeric
		setIndex = 3
		mapping = 16..23
	s16=~		~~ (this the DummySampler generated by the HLSLCrossCompiler)
		set = Numeric
		setIndex = 3
		mapping = 27

	b0..4=~
		set = Numeric
		setIndex = 3
		mapping = 23..27
	b4..7=~
		set = Material
		setIndex = 1
		mapping = 0..3
	b7..13=~
		set = Sequencer
		setIndex = 0
		mapping = 0..6

RootSignature=~
	name = GraphicsMain
	Set=~
		name = Sequencer
		type = Adaptive
		uniformStream = 0
	Set=~
		name = Material
		type = Adaptive
		uniformStream = 1
	Set=~
		name = Draw
		type = Adaptive
		uniformStream = 2
	Set=~
		name = Numeric
		type = Numeric
	legacyBindings = MainLegacyBinding
	PushConstants=~
		name = LocalTransform

MainRootSignature = GraphicsMain
)--";

namespace RenderCore { namespace Metal_Vulkan { namespace Internal
{
#if 0
	class BoundSignatureFile::Pimpl
	{
	public:
		std::vector<std::pair<uint64_t, DescriptorSet>> _descriptorSetLayouts;
		VkShaderStageFlags								_stageFlags;
		ObjectFactory*		_factory;
		GlobalPools*		_globalPools;
	};

	auto BoundSignatureFile::GetDescriptorSet(uint64_t signatureFile, uint64_t hashName) const -> const DescriptorSet*
	{
		auto h = HashCombine(signatureFile, hashName);
		auto i = LowerBound(_pimpl->_descriptorSetLayouts, h);
		if (i != _pimpl->_descriptorSetLayouts.end() && i->first == h)
			return &i->second;
		return nullptr;
	}

	void BoundSignatureFile::RegisterSignatureFile(uint64_t hashName, const DescriptorSetSignatureFile& signatureFile)
	{
		// Each descriptor set layout is initialized from the root signature
		// This allows us to create a single global setting that can be used broadly across
		// many "pipelines"

		#if defined(_DEBUG)
			ValidateRootSignature(_pimpl->_factory->GetPhysicalDevice(), signatureFile);
		#endif

		_pimpl->_descriptorSetLayouts.reserve(_pimpl->_descriptorSetLayouts.size() + signatureFile._descriptorSets.size());

		for (const auto& s:signatureFile._descriptorSets) {
			DescriptorSet ds;
			ds._layout = CreateDescriptorSetLayout(*_pimpl->_factory, *s, _pimpl->_stageFlags);
			
			{
				ProgressiveDescriptorSetBuilder builder(*_pimpl->_globalPools);
				builder.BindDummyDescriptors(*s, (1ull<<uint64_t(s->_bindings.size()))-1ull);
				ds._blankBindings = _pimpl->_globalPools->_longTermDescriptorPool.Allocate(ds._layout.get());
				VULKAN_VERBOSE_DEBUG_ONLY(ds._blankBindingsDescription._descriptorSetInfo = s_dummyDescriptorSetName);
				builder.FlushChanges(
					_pimpl->_factory->GetDevice().get(),
					ds._blankBindings.get(),
					0, 0 VULKAN_VERBOSE_DEBUG_ONLY(, ds._blankBindingsDescription));
			}

			VULKAN_VERBOSE_DEBUG_ONLY(ds._name = s->_name);
			_pimpl->_descriptorSetLayouts.emplace_back(std::make_pair(HashCombine(hashName, s->_hashName), std::move(ds)));
		}
		std::sort(
			_pimpl->_descriptorSetLayouts.begin(),
			_pimpl->_descriptorSetLayouts.end(),
			CompareFirst<uint64_t, DescriptorSet>());
	}

	BoundSignatureFile::BoundSignatureFile(ObjectFactory& objectFactory, GlobalPools& globalPools, VkShaderStageFlags stageFlags)
	{
		_pimpl = std::make_unique<Pimpl>();
		_pimpl->_stageFlags = stageFlags;
		_pimpl->_factory = &objectFactory;
		_pimpl->_globalPools = &globalPools;
	}

	BoundSignatureFile::~BoundSignatureFile()
	{}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////

	static const std::string s_dummyDescriptorString{"<DummyDescriptor>"};

	const DescriptorSetCacheResult*	CompiledDescriptorSetLayoutCache::CompileDescriptorSetLayout(
		const DescriptorSetSignature& signature,
		const std::string& name,
		VkShaderStageFlags stageFlags)
	{
		auto hash = HashCombine(signature.GetHash(), stageFlags);
		auto i = LowerBound(_cache, hash);
		if (i != _cache.end() && i->first == hash)
			return i->second.get();

		auto ds = std::make_unique<DescriptorSetCacheResult>();
		ds->_layout = std::make_unique<CompiledDescriptorSetLayout>(*_objectFactory, MakeIteratorRange(signature._slots), stageFlags);
		
		{
			ProgressiveDescriptorSetBuilder builder { MakeIteratorRange(signature._slots) };
			builder.BindDummyDescriptors(*_globalPools, (1ull<<uint64_t(signature._slots.size()))-1ull);
			ds->_blankBindings = _globalPools->_longTermDescriptorPool.Allocate(ds->_layout->GetUnderlying());
			VULKAN_VERBOSE_DEBUG_ONLY(ds->_blankBindingsDescription._descriptorSetInfo = s_dummyDescriptorString);
			builder.FlushChanges(
				_objectFactory->GetDevice().get(),
				ds->_blankBindings.get(),
				0, 0 VULKAN_VERBOSE_DEBUG_ONLY(, ds->_blankBindingsDescription));
		}

		VULKAN_VERBOSE_DEBUG_ONLY(ds->_name = name);

		i = _cache.insert(i, std::make_pair(hash, std::move(ds)));
		return i->second.get();
	}

	CompiledDescriptorSetLayoutCache::CompiledDescriptorSetLayoutCache(ObjectFactory& objectFactory, GlobalPools& globalPools)
	: _objectFactory(&objectFactory)
	, _globalPools(&globalPools)
	{}

	CompiledDescriptorSetLayoutCache::~CompiledDescriptorSetLayoutCache() {}

	std::shared_ptr<CompiledDescriptorSetLayoutCache> CreateCompiledDescriptorSetLayoutCache()
	{
		return std::make_shared<CompiledDescriptorSetLayoutCache>(
			GetObjectFactory(), 
			*VulkanGlobalsTemp::GetInstance()._globalPools);
	}

}}}

namespace RenderCore { namespace Metal_Vulkan
{
	CompiledPipelineLayout::CompiledPipelineLayout(
		ObjectFactory& factory,
		IteratorRange<const DescriptorSetBinding*> descriptorSets,
		IteratorRange<const PushConstantsBinding*> pushConstants)
	{
		for (auto&c:_descriptorSetBindingNames) c = 0;
		for (auto&c:_pushConstantBufferBindingNames) c = 0;

		_descriptorSetCount = std::min((unsigned)descriptorSets.size(), s_maxDescriptorSetCount);
		_pushConstantBufferCount = std::min((unsigned)pushConstants.size(), s_maxPushConstantBuffers);
		VkDescriptorSetLayout rawDescriptorSetLayouts[s_maxDescriptorSetCount];
		for (unsigned c=0; c<_descriptorSetCount; ++c) {
			_descriptorSetLayouts[c] = descriptorSets[c]._layout;
			rawDescriptorSetLayouts[c] = _descriptorSetLayouts[c]->GetUnderlying();
			_blankDescriptorSets[c] = descriptorSets[c]._blankDescriptorSet;
			_descriptorSetBindingNames[c] = Hash64(descriptorSets[c]._name);

			#if defined(VULKAN_VERBOSE_DEBUG)
				_blankDescriptorSetsDebugInfo[c] = descriptorSets[c]._blankDescriptorSetDebugInfo;
				_descriptorSetStringNames[c] = descriptorSets[c]._name;
			#endif
		}

		// Vulkan is particular about how push constants work!
		// Each range is bound to specific shader stages; but you can't overlap ranges,
		// even if those ranges apply to different shader stages. Well, technically we
		// can here, in the layout. But when we come to call vkCmdPushConstants, we'll get
		// a validation error -- (when pushing constants to a particular range, we must set
		// the shader stages for all ranges that overlap the bytes pushed).
		// So if we have push constants used by different shaders in a shader program (ie, vertex & fragment shaders),
		// they must actually agree about the position of specific uniforms. You can't have different
		// shaders using the same byte offset for different uniforms. The most practical way
		// to deal with this would might be to only use push constants in a specific shader (ie, only in vertex
		// shaders, never in fragment shaders).
		unsigned pushConstantIterator = 0;
		for (unsigned c=0; c<_pushConstantBufferCount; ++c) {
			assert(pushConstants[c]._cbSize != 0);
			assert(pushConstants[c]._stageFlags != 0);
			auto size = CeilToMultiplePow2(pushConstants[c]._cbSize, 4);
			
			auto startOffset = pushConstantIterator;
			pushConstantIterator += size;

			assert(startOffset == CeilToMultiplePow2(startOffset, 4));
			_pushConstantRanges[c] = VkPushConstantRange { pushConstants[c]._stageFlags, startOffset, size };
			_pushConstantBufferBindingNames[c] = Hash64(pushConstants[c]._name);
		}

		_pipelineLayout = factory.CreatePipelineLayout(
			MakeIteratorRange(rawDescriptorSetLayouts, &rawDescriptorSetLayouts[_descriptorSetCount]),
			MakeIteratorRange(_pushConstantRanges, &_pushConstantRanges[_pushConstantBufferCount]));
	}

	#if defined(VULKAN_VERBOSE_DEBUG)
		void CompiledPipelineLayout::WriteDebugInfo(
			std::ostream&& output,
			IteratorRange<const CompiledShaderByteCode**> shaders,
			IteratorRange<const DescriptorSetDebugInfo*> descriptorSets)
		{
			Log(Verbose) << "-------------Descriptors------------" << std::endl;
			for (unsigned descSetIdx=0; descSetIdx<s_maxDescriptorSetCount; ++descSetIdx) {
				WriteDescriptorSet(
					std::move(output),
					(descSetIdx < descriptorSets.size()) ? descriptorSets[descSetIdx] : _blankDescriptorSetsDebugInfo[descSetIdx],
					(descSetIdx < _descriptorSetCount) ? _descriptorSetLayouts[descSetIdx]->GetDescriptorSlots() : IteratorRange<const DescriptorSlot*>{},
					(descSetIdx < _descriptorSetCount) ? _descriptorSetStringNames[descSetIdx] : "<<unbound>>",
					Internal::VulkanGlobalsTemp::GetInstance()._legacyRegisterBindings,
					shaders,
					descSetIdx,
					descSetIdx < descriptorSets.size());
			}
		}
	#endif

}}

namespace RenderCore { namespace Metal_Vulkan { namespace Internal
{
#if 0
	std::shared_ptr<CompiledPipelineLayout> CreateCompiledPipelineLayout(
		ObjectFactory& factory,
		CompiledDescriptorSetLayoutCache& cache,
		IteratorRange<const PartialPipelineDescriptorsLayout*> partialLayouts,
		VkShaderStageFlags stageFlags)
	{
		std::vector<CompiledPipelineLayout::DescriptorSetBinding> descriptorSetBindings;
		std::vector<CompiledPipelineLayout::PushConstantsBinding> pushConstantBindings;

		for (const auto&partial:partialLayouts) {
			for (auto& desc:partial._descriptorSets) {
				assert(desc._pipelineLayoutBindingIndex < s_maxDescriptorSetCount);
				assert(desc._pipelineLayoutBindingIndex <= descriptorSetBindings.size() || !descriptorSetBindings[desc._pipelineLayoutBindingIndex]._layout);

				auto* compiled = cache.CompileDescriptorSetLayout(*desc._signature, desc._name, stageFlags);
				if (compiled) {
					// todo -- check for multiples bound to the same index
					assert(desc._pipelineLayoutBindingIndex < s_maxDescriptorSetCount);

					CompiledPipelineLayout::DescriptorSetBinding binding;
					binding._name = desc._name;
					binding._layout = compiled->_layout;
					binding._blankDescriptorSet = compiled->_blankBindings;

					#if defined(VULKAN_VERBOSE_DEBUG)
						binding._blankDescriptorSetDebugInfo = compiled->_blankBindingsDescription;
					#endif

					if (descriptorSetBindings.size() <= desc._pipelineLayoutBindingIndex)
						descriptorSetBindings.resize(desc._pipelineLayoutBindingIndex+1);
					descriptorSetBindings[desc._pipelineLayoutBindingIndex] = std::move(binding);
				}
			}

			pushConstantBindings.reserve(partial._pushConstants.size());
			for (const auto& s:partial._pushConstants)
				pushConstantBindings.push_back(CompiledPipelineLayout::PushConstantsBinding{s._name, s._rangeSize, stageFlags});
		}

		return std::make_shared<CompiledPipelineLayout>(
			factory,
			MakeIteratorRange(descriptorSetBindings),
			MakeIteratorRange(pushConstantBindings));
	}
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////

	class DescSetLimits
	{
	public:
		unsigned _sampledImageCount;
		unsigned _samplerCount;
		unsigned _uniformBufferCount;
		unsigned _storageBufferCount;
		unsigned _storageImageCount;
		unsigned _inputAttachmentCount;

		void Add(const DescSetLimits& other)
		{
			_sampledImageCount += other._sampledImageCount;
			_samplerCount += other._samplerCount;
			_uniformBufferCount += other._uniformBufferCount;
			_storageBufferCount += other._storageBufferCount;
			_storageImageCount += other._storageImageCount;
			_inputAttachmentCount += other._inputAttachmentCount;
		}
	};

	static DescSetLimits BuildLimits(const DescriptorSetSignature& setSig)
	{
		DescSetLimits result = {};
		for (auto& b:setSig._slots) {
			switch (b._type) {
			case DescriptorType::Sampler:
				result._samplerCount += b._count;
				break;

			case DescriptorType::Texture:
				result._sampledImageCount += b._count;
				break;

			case DescriptorType::ConstantBuffer:
				result._uniformBufferCount += b._count;
				break;

			case DescriptorType::UnorderedAccessBuffer:
				result._storageBufferCount += b._count;
				break;

			case DescriptorType::UnorderedAccessTexture:
				result._storageImageCount += b._count;
				break;

			default:
				break;
			}
		}
		return result;
	}

	static void ValidatePipelineLayout(
		VkPhysicalDevice physDev,
		const PipelineLayoutDesc& pipelineLayout)
	{
		// Validate the root signature against the physical device, and throw an exception
		// if there are problems.
		// Things to check:
		//      VkPhysicalDeviceLimits.maxBoundDescriptorSets
		//      VkPhysicalDeviceLimits.maxPerStageDescriptor*
		//      VkPhysicalDeviceLimits.maxDescriptorSet*

		VkPhysicalDeviceProperties props;
		vkGetPhysicalDeviceProperties(physDev, &props);
		const auto& limits = props.limits;

		// Here, we are assuming all descriptors apply equally to all stages.
		DescSetLimits totalLimits = {};
		for (const auto& s:pipelineLayout.GetDescriptorSets()) {
			auto ds = BuildLimits(s._signature);
			// not really clear how these ones work...?
			if (    ds._sampledImageCount > limits.maxDescriptorSetSampledImages
				||  ds._samplerCount > limits.maxPerStageDescriptorSamplers
				||  ds._uniformBufferCount > limits.maxPerStageDescriptorUniformBuffers
				||  ds._storageBufferCount > limits.maxPerStageDescriptorStorageBuffers
				||  ds._storageImageCount > limits.maxPerStageDescriptorStorageImages
				||  ds._inputAttachmentCount > limits.maxPerStageDescriptorInputAttachments)
				Throw(::Exceptions::BasicLabel("Root signature exceeds the maximum number of bound resources in a single descriptor set that is supported by the device"));
			totalLimits.Add(ds);
		}

		if (    totalLimits._sampledImageCount > limits.maxDescriptorSetSampledImages
			||  totalLimits._samplerCount > limits.maxPerStageDescriptorSamplers
			||  totalLimits._uniformBufferCount > limits.maxPerStageDescriptorUniformBuffers
			||  totalLimits._storageBufferCount > limits.maxPerStageDescriptorStorageBuffers
			||  totalLimits._storageImageCount > limits.maxPerStageDescriptorStorageImages
			||  totalLimits._inputAttachmentCount > limits.maxPerStageDescriptorInputAttachments)
			Throw(::Exceptions::BasicLabel("Root signature exceeds the maximum number of bound resources per stage that is supported by the device"));
	}

	VulkanGlobalsTemp& VulkanGlobalsTemp::GetInstance()
	{
		static VulkanGlobalsTemp s_instance;
		return s_instance;
	}

	/*const std::shared_ptr<CompiledPipelineLayout>& VulkanGlobalsTemp::GetPipelineLayout(const ShaderProgram&)
	{
		return _graphicsPipelineLayout;
	}
	const std::shared_ptr<CompiledPipelineLayout>& VulkanGlobalsTemp::GetPipelineLayout(const ComputeShader&)
	{
		return _computePipelineLayout;
	}

	const LegacyRegisterBindingDesc& VulkanGlobalsTemp::GetLegacyRegisterBinding()
	{
		return *_graphicsRootSignatureFile->GetLegacyRegisterBinding(Hash64(_graphicsRootSignatureFile->GetRootSignature(Hash64(_graphicsRootSignatureFile->_mainRootSignature))->_legacyBindings));
	}*/

	VulkanGlobalsTemp::VulkanGlobalsTemp() 
	{
		// _graphicsRootSignatureFile = std::make_shared<Metal_Vulkan::DescriptorSetSignatureFile>(ROOT_SIGNATURE_CFG);
		// _computeRootSignatureFile = std::make_shared<Metal_Vulkan::DescriptorSetSignatureFile>(ROOT_SIGNATURE_COMPUTE_CFG);

		// hack -- temporary configuration
		/*{
			InputStreamFormatter<> formatter(MakeStringSection(s_rootSignatureGraphicsDefault));
			_graphicsRootSignatureFile = std::make_shared<Metal_Vulkan::DescriptorSetSignatureFile>(formatter, ::Assets::DirectorySearchRules{}, nullptr);
		}
		_computeRootSignatureFile = _graphicsRootSignatureFile;*/
	}

	VulkanGlobalsTemp::~VulkanGlobalsTemp() {}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if 0
	std::shared_ptr<PartialPipelineDescriptorsLayout> CreatePartialPipelineDescriptorsLayout(
		const DescriptorSetSignatureFile& signatureFile, PipelineType pipelineType)
	{
		auto result = std::make_shared<PartialPipelineDescriptorsLayout>();

		auto& globals = VulkanGlobalsTemp::GetInstance();
		const auto& root = *signatureFile.GetRootSignature(Hash64(signatureFile._mainRootSignature));
		result->_descriptorSets.reserve(root._descriptorSets.size());
		for (unsigned c=0; c<root._descriptorSets.size(); ++c) {
			const auto&d = root._descriptorSets[c];
			result->_descriptorSets.emplace_back(
				PartialPipelineDescriptorsLayout::DescriptorSet {
					signatureFile.GetDescriptorSet(d._hashName),
					c,
					d._name
				});
		}

		auto shaderStageMask = 0;
		if (pipelineType == PipelineType::Graphics) {
			shaderStageMask = VK_SHADER_STAGE_ALL_GRAPHICS;
		} else {
			shaderStageMask = VK_SHADER_STAGE_COMPUTE_BIT;
		}

		for (unsigned c=0; c<root._pushConstants.size(); ++c) {
			auto* sig = signatureFile.GetPushConstantsRangeSignature(Hash64(root._pushConstants[c]));
			if (sig && (sig->_stages & shaderStageMask)) {
				auto newSig = *sig;
				newSig._stages &= shaderStageMask;
				result->_pushConstants.push_back(std::move(newSig));
			}
		}

		result->_legacyRegisterBinding = signatureFile.GetLegacyRegisterBinding(Hash64(root._legacyBindings));
		return result;
	}
#endif
	
}}}

