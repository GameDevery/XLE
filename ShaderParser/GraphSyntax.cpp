// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma warning(disable:4800) // 'int': forcing value to bool 'true' or 'false' (performance warning))

#include "GraphSyntax.h"
#include "ShaderPatcher.h"
#include "ShaderPatcher_Internal.h"
#include "AntlrHelper.h"
#include "Grammar/GraphSyntaxLexer.h"
#include "Grammar/GraphSyntaxParser.h"
#include "Grammar/GraphSyntaxEval.h"
#include "../Utility/FunctionUtils.h"
#include <unordered_map>
#include <stack>

#include <iostream>


namespace ShaderPatcher
{
	using namespace ShaderSourceParser::AntlrHelper;

	class WorkingNodeGraph
	{
	public:
		NodeGraph _graph;

		struct Connector { uint32_t nodeId; std::string _name; };
		std::vector<Connector> _connectors;
		std::vector<std::string> _literalConnectors;
		std::unordered_map<std::string, uint32_t> _nodeNameMapping;
		std::unordered_map<std::string, std::pair<uint32_t, uint32_t>> _slotNameMapping;
		std::stack<uint32_t> _activeRNodes;
		std::stack<uint32_t> _activeLNodes;
	};

	static pANTLR3_BASE_TREE BuildAST(struct GraphSyntaxParser_Ctx_struct& parser)
    {
        ExceptionContext exceptionContext;
        auto result = parser.entrypoint(&parser).tree;
        if (!exceptionContext._exceptions._errors.empty())
            Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		return result;
    }

    NodeGraph ParseGraphSyntax(StringSection<char> sourceCode)
    {
        AntlrPtr<struct ANTLR3_INPUT_STREAM_struct>	inputStream = antlr3StringStreamNew(
            (ANTLR3_UINT8*)sourceCode.begin(), ANTLR3_ENC_8BIT, 
            (unsigned)sourceCode.size(), (ANTLR3_UINT8*)"InputStream");

        if (!inputStream) Throw(::Exceptions::BasicLabel("Unable to create the input stream due to malloc() failure\n"));
		AntlrPtr<struct GraphSyntaxLexer_Ctx_struct> lxr = GraphSyntaxLexerNew(inputStream);	    // CLexerNew is generated by ANTLR
		if (!lxr) Throw(::Exceptions::BasicLabel("Unable to create the lexer due to malloc() failure\n"));

		AntlrPtr<struct ANTLR3_COMMON_TOKEN_STREAM_struct> tokenStream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
		if (!tokenStream) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate token stream\n"));
		AntlrPtr<struct GraphSyntaxParser_Ctx_struct> psr = GraphSyntaxParserNew(tokenStream);  // CParserNew is generated by ANTLR3
		if (!psr) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate parser\n"));

		auto* ast = BuildAST(*psr);

		StructureDescription(std::cout, ast);

		AntlrPtr<struct ANTLR3_COMMON_TREE_NODE_STREAM_struct> nodes = antlr3CommonTreeNodeStreamNewTree(ast, ANTLR3_SIZE_HINT);
		AntlrPtr<struct GraphSyntaxEval_Ctx_struct> evalTree = GraphSyntaxEvalNew(nodes);

		ExceptionContext exceptionContext;
		WorkingNodeGraph ng;
		evalTree->_userData = &ng;
		evalTree->entrypoint(evalTree);
		if (!exceptionContext._exceptions._errors.empty())
			Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		
		return std::move(ng._graph);
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

	std::string ReadGraphSyntax(StringSection<char> input, const ::Assets::DirectorySearchRules& searchRules)
	{
		auto graph = ParseGraphSyntax(input);
		
		std::string result;
		// Find each slot implementation in the graph; trim it out, and then
		// build a function.
		auto nodes = graph.GetNodes();
		for (const auto& n:nodes) {
			if (n.ArchiveName().find("Signal_") != std::string::npos && n.GetType() == Node::Type::SlotOutput) {
				NodeGraph subGraph = graph;

				auto splitName = ShaderPatcher::SplitArchiveName(n.ArchiveName());
				subGraph.SetName(std::get<1>(splitName) + "_impl");
				subGraph.SetSearchRules(searchRules);
				// auto ni = n.NodeId();
				// subGraph.Trim(&ni, &ni+1);

				std::string slotImplementation;
				FunctionInterface generatedInterface;
				std::tie(slotImplementation, generatedInterface) = GenerateFunction(subGraph);
				result += slotImplementation;

				const auto& slotSig = ShaderPatcher::LoadFunctionSignature(splitName, searchRules);
				result += GenerateScaffoldFunction(slotSig, generatedInterface);
			}
		}

		return result;
	}

}

typedef unsigned NodeId;
typedef unsigned ConnectorId;
typedef unsigned ConnectionId;

extern "C" NodeId RNode_Register(const void* ctx, const char archiveName[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;

	NodeId nextId = (NodeId)ng->_graph.GetNodes().size();
	ShaderPatcher::Node newNode(archiveName?archiveName:"", nextId, ShaderPatcher::Node::Type::Procedure);
	ng->_graph.Add(std::move(newNode));
	return nextId;
}

extern "C" NodeId LSlot_Register(const void* ctx, const char archiveName[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;

	NodeId nextId = (NodeId)ng->_graph.GetNodes().size();
	ShaderPatcher::Node newNode(archiveName, nextId, ShaderPatcher::Node::Type::SlotOutput);
	ng->_graph.Add(std::move(newNode));
	return nextId;
}

extern "C" NodeId RSlot_Register(const void* ctx, const char archiveName[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;

	NodeId nextId = (NodeId)ng->_graph.GetNodes().size();
	ShaderPatcher::Node newNode(archiveName, nextId, ShaderPatcher::Node::Type::SlotInput);
	ng->_graph.Add(std::move(newNode));
	return nextId;
}

extern "C" ConnectorId Connector_Register(const void* ctx, NodeId node, const char connectorName[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	ConnectorId nextId = (ConnectorId)ng->_connectors.size();
	ng->_connectors.push_back({node, connectorName});
	return nextId;
}

extern "C" ConnectorId LiteralConnector_Register(const void* ctx, const char literal[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	ConnectorId nextId = 0xf0000000u | (ConnectorId)ng->_literalConnectors.size();
	ng->_literalConnectors.push_back(literal);
	return nextId;
}

extern "C" ConnectionId Connection_Register(const void* ctx, ConnectorId left, ConnectorId right)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	
	if (left >= ng->_connectors.size())
		return ~0u;

	if (right & 0xf0000000u) {
		if ((right & ~0xf0000000u) >= ng->_literalConnectors.size())
			return ~0u;

		ShaderPatcher::ConstantConnection connection(
			ng->_connectors[left].nodeId, ng->_connectors[left]._name,
			ng->_literalConnectors[right & ~0xf0000000u]);
		ng->_graph.Add(std::move(connection));
	} else {
		if (right >= ng->_connectors.size())
			return ~0u;

		ShaderPatcher::NodeConnection connection(
			ng->_connectors[left].nodeId, ng->_connectors[right].nodeId,
			ng->_connectors[left]._name, ng->_connectors[right]._name,
			std::string());
		ng->_graph.Add(std::move(connection));
	}

	return ~0u;
}

extern "C" void Node_Name(const void* ctx, NodeId id, const char name[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_nodeNameMapping.insert({name, id});
}

extern "C" void Slot_Name(const void* ctx, NodeId lnode, NodeId rnode, const char name[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_slotNameMapping.insert({name, {lnode, rnode}});
}

extern "C" NodeId LNode_Find(const void* ctx, const char name[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	std::string n(name);
	auto i = ng->_nodeNameMapping.find(n);
	if (i != ng->_nodeNameMapping.end()) return i->second;
	auto si = ng->_slotNameMapping.find(n);
	if (si != ng->_slotNameMapping.end()) return si->second.first;
	return ~0u;
}

extern "C" NodeId RNode_Find(const void* ctx, const char name[])
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	std::string n(name);
	auto i = ng->_nodeNameMapping.find(n);
	if (i != ng->_nodeNameMapping.end()) return i->second;
	auto si = ng->_slotNameMapping.find(n);
	if (si != ng->_slotNameMapping.end()) return si->second.second;
	return ~0u;
}

extern "C" void RNode_Push(const void* ctx, NodeId id)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_activeRNodes.push(id);
}

extern "C" void RNode_Pop(const void* ctx)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_activeRNodes.pop();
}

extern "C" NodeId RNode_GetActive(const void* ctx)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	if (ng->_activeRNodes.empty())
		return ~0u;
	return ng->_activeRNodes.top();
}

extern "C" void LNode_Push(const void* ctx, NodeId id)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_activeLNodes.push(id);
}

extern "C" void LNode_Pop(const void* ctx)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	ng->_activeLNodes.pop();
}

extern "C" NodeId LNode_GetActive(const void* ctx)
{
	auto* ng = (ShaderPatcher::WorkingNodeGraph*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData;
	if (ng->_activeLNodes.empty())
		return ~0u;
	return ng->_activeLNodes.top();
}

